diff -Naur Python-2.7.13/Modules/Setup ../Python-2.7.13/Modules/Setup
--- Python-2.7.13/Modules/Setup	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/Setup	2017-07-04 15:04:11.000000000 +0200
@@ -0,0 +1,499 @@
+# -*- makefile -*-
+# The file Setup is used by the makesetup script to construct the files
+# Makefile and config.c, from Makefile.pre and config.c.in,
+# respectively.  The file Setup itself is initially copied from
+# Setup.dist; once it exists it will not be overwritten, so you can edit
+# Setup to your heart's content.  Note that Makefile.pre is created
+# from Makefile.pre.in by the toplevel configure script.
+
+# (VPATH notes: Setup and Makefile.pre are in the build directory, as
+# are Makefile and config.c; the *.in and *.dist files are in the source
+# directory.)
+
+# Each line in this file describes one or more optional modules.
+# Modules enabled here will not be compiled by the setup.py script,
+# so the file can be used to override setup.py's behavior.
+
+# Lines have the following structure:
+#
+# <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
+#
+# <sourcefile> is anything ending in .c (.C, .cc, .c++ are C++ files)
+# <cpparg> is anything starting with -I, -D, -U or -C
+# <library> is anything ending in .a or beginning with -l or -L
+# <module> is anything else but should be a valid Python
+# identifier (letters, digits, underscores, beginning with non-digit)
+#
+# (As the makesetup script changes, it may recognize some other
+# arguments as well, e.g. *.so and *.sl as libraries.  See the big
+# case statement in the makesetup script.)
+#
+# Lines can also have the form
+#
+# <name> = <value>
+#
+# which defines a Make variable definition inserted into Makefile.in
+#
+# Finally, if a line contains just the word "*shared*" (without the
+# quotes but with the stars), then the following modules will not be
+# built statically.  The build process works like this:
+#
+# 1. Build all modules that are declared as static in Modules/Setup,
+#    combine them into libpythonxy.a, combine that into python.
+# 2. Build all modules that are listed as shared in Modules/Setup.
+# 3. Invoke setup.py. That builds all modules that
+#    a) are not builtin, and
+#    b) are not listed in Modules/Setup, and
+#    c) can be build on the target
+#
+# Therefore, modules declared to be shared will not be
+# included in the config.c file, nor in the list of objects to be
+# added to the library archive, and their linker options won't be
+# added to the linker options. Rules to create their .o files and
+# their shared libraries will still be added to the Makefile, and
+# their names will be collected in the Make variable SHAREDMODS.  This
+# is used to build modules as shared libraries.  (They can be
+# installed using "make sharedinstall", which is implied by the
+# toplevel "make install" target.)  (For compatibility,
+# *noconfig* has the same effect as *shared*.)
+#
+# In addition, *static* explicitly declares the following modules to
+# be static.  Lines containing "*static*" and "*shared*" may thus
+# alternate throughout this file.
+
+# NOTE: As a standard policy, as many modules as can be supported by a
+# platform should be present.  The distribution comes with all modules
+# enabled that are supported by most platforms and don't require you
+# to ftp sources from elsewhere.
+
+
+# Some special rules to define PYTHONPATH.
+# Edit the definitions below to indicate which options you are using.
+# Don't add any whitespace or comments!
+
+# Directories where library files get installed.
+# DESTLIB is for Python modules; MACHDESTLIB for shared libraries.
+DESTLIB=$(LIBDEST)
+MACHDESTLIB=$(BINLIBDEST)
+
+# NOTE: all the paths are now relative to the prefix that is computed
+# at run time!
+
+# Standard path -- don't edit.
+# No leading colon since this is the first entry.
+# Empty since this is now just the runtime prefix.
+DESTPATH=
+
+# Site specific path components -- should begin with : if non-empty
+SITEPATH=
+
+# Standard path components for test modules
+TESTPATH=
+
+# Path components for machine- or system-dependent modules and shared libraries
+MACHDEPPATH=:$(PLATDIR)
+EXTRAMACHDEPPATH=
+
+# Path component for the Tkinter-related modules
+# The TKPATH variable is always enabled, to save you the effort.
+TKPATH=:lib-tk
+
+# Path component for old modules.
+OLDPATH=:lib-old
+
+COREPYTHONPATH=$(DESTPATH)$(SITEPATH)$(TESTPATH)$(MACHDEPPATH)$(EXTRAMACHDEPPATH)$(TKPATH)$(OLDPATH)
+PYTHONPATH=$(COREPYTHONPATH)
+
+
+# The modules listed here can't be built as shared libraries for
+# various reasons; therefore they are listed here instead of in the
+# normal order.
+
+# This only contains the minimal set of modules required to run the 
+# setup.py script in the root of the Python source tree.
+
+posix posixmodule.c		# posix (UNIX) system calls
+errno errnomodule.c		# posix (UNIX) errno values
+pwd pwdmodule.c			# this is needed to find out the user's home dir
+				# if $HOME is not set
+_sre _sre.c			# Fredrik Lundh's new regular expressions
+_codecs _codecsmodule.c		# access to the builtin codecs and codec registry
+_weakref _weakref.c             # weak references
+
+# The zipimport module is always imported at startup. Having it as a
+# builtin module avoids some bootstrapping problems and reduces overhead.
+zipimport zipimport.c
+
+# The rest of the modules listed in this file are all commented out by
+# default.  Usually they can be detected and built as dynamically
+# loaded modules by the new setup.py script added in Python 2.1.  If
+# you're on a platform that doesn't support dynamic loading, want to 
+# compile modules statically into the Python binary, or need to 
+# specify some odd set of compiler switches, you can uncomment the 
+# appropriate lines below.
+
+# ======================================================================
+
+# The Python symtable module depends on .h files that setup.py doesn't track
+_symtable symtablemodule.c
+
+# The SGI specific GL module:
+
+GLHACK=-Dclear=__GLclear
+#gl glmodule.c cgensupport.c -I$(srcdir) $(GLHACK) -lgl -lX11
+
+# Pure module.  Cannot be linked dynamically.
+# -DWITH_QUANTIFY, -DWITH_PURIFY, or -DWITH_ALL_PURE
+#WHICH_PURE_PRODUCTS=-DWITH_ALL_PURE
+#PURE_INCLS=-I/usr/local/include
+#PURE_STUBLIBS=-L/usr/local/lib -lpurify_stubs -lquantify_stubs
+#pure puremodule.c $(WHICH_PURE_PRODUCTS) $(PURE_INCLS) $(PURE_STUBLIBS)
+
+# Uncommenting the following line tells makesetup that all following
+# modules are to be built as shared libraries (see above for more
+# detail; also note that *static* reverses this effect):
+
+#*shared*
+
+# GNU readline.  Unlike previous Python incarnations, GNU readline is
+# now incorporated in an optional module, configured in the Setup file
+# instead of by a configure script switch.  You may have to insert a
+# -L option pointing to the directory where libreadline.* lives,
+# and you may have to change -ltermcap to -ltermlib or perhaps remove
+# it, depending on your system -- see the GNU readline instructions.
+# It's okay for this to be a shared library, too.
+
+#readline readline.c -lreadline -ltermcap
+
+
+# Modules that should always be present (non UNIX dependent):
+
+#array arraymodule.c	# array objects
+#cmath cmathmodule.c _math.c # -lm # complex math library functions
+#math mathmodule.c _math.c # -lm # math library functions, e.g. sin()
+#_struct _struct.c	# binary structure packing/unpacking
+#time timemodule.c # -lm # time operations and variables
+#operator operator.c	# operator.add() and similar goodies
+#_testcapi _testcapimodule.c    # Python C API test module
+#_random _randommodule.c	# Random number generator
+#_collections _collectionsmodule.c # Container types
+#_heapq _heapqmodule.c		# Heapq type
+#itertools itertoolsmodule.c	# Functions creating iterators for efficient looping 
+#strop stropmodule.c		# String manipulations
+#_functools _functoolsmodule.c	# Tools for working with functions and callable objects
+#_elementtree -I$(srcdir)/Modules/expat -DHAVE_EXPAT_CONFIG_H -DUSE_PYEXPAT_CAPI _elementtree.c	# elementtree accelerator
+#_pickle _pickle.c	# pickle accelerator
+#datetime datetimemodule.c	# date/time type
+#_bisect _bisectmodule.c	# Bisection algorithms
+
+#unicodedata unicodedata.c    # static Unicode character database
+
+# access to ISO C locale support
+#_locale _localemodule.c  # -lintl
+
+# Standard I/O baseline
+#_io -I$(srcdir)/Modules/_io _io/bufferedio.c _io/bytesio.c _io/fileio.c _io/iobase.c _io/_iomodule.c _io/stringio.c _io/textio.c
+
+
+# Modules with some UNIX dependencies -- on by default:
+# (If you have a really backward UNIX, select and socket may not be
+# supported...)
+
+#fcntl fcntlmodule.c	# fcntl(2) and ioctl(2)
+#spwd spwdmodule.c		# spwd(3) 
+#grp grpmodule.c		# grp(3)
+#select selectmodule.c	# select(2); not on ancient System V
+
+# Memory-mapped files (also works on Win32).
+#mmap mmapmodule.c
+
+# CSV file helper
+#_csv _csv.c
+
+# Socket module helper for socket(2)
+#_socket socketmodule.c timemodule.c
+
+# Socket module helper for SSL support; you must comment out the other
+# socket line above, and possibly edit the SSL variable:
+SSL=../blink/Frameworks
+_ssl _ssl.c \
+	-DUSE_SSL -I$(SSL)/include \
+	-F$(SSL) -Framework openssl -lcrypto
+
+# The crypt module is now disabled by default because it breaks builds
+# on many systems (where -lcrypt is needed), e.g. Linux (I believe).
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#crypt cryptmodule.c # -lcrypt	# crypt(3); needs -lcrypt on some systems
+
+
+# Some more UNIX dependent modules -- off by default, since these
+# are not supported by all UNIX systems:
+
+#nis nismodule.c -lnsl	# Sun yellow pages -- not everywhere
+#termios termios.c	# Steen Lumholt's termios module
+#resource resource.c	# Jeremy Hylton's rlimit interface
+
+
+# Multimedia modules -- off by default.
+# These don't work for 64-bit platforms!!!
+# #993173 says audioop works on 64-bit platforms, though.
+# These represent audio samples or images as strings:
+
+#audioop audioop.c	# Operations on audio samples
+#imageop imageop.c	# Operations on images
+
+
+# Note that the _md5 and _sha modules are normally only built if the
+# system does not have the OpenSSL libs containing an optimized version.
+
+# The _md5 module implements the RSA Data Security, Inc. MD5
+# Message-Digest Algorithm, described in RFC 1321.  The necessary files
+# md5.c and md5.h are included here.
+
+#_md5 md5module.c md5.c
+
+
+# The _sha module implements the SHA checksum algorithms.
+# (NIST's Secure Hash Algorithms.)
+#_sha shamodule.c
+#_sha256 sha256module.c
+#_sha512 sha512module.c
+
+
+# SGI IRIX specific modules -- off by default.
+
+# These module work on any SGI machine:
+
+# *** gl must be enabled higher up in this file ***
+#fm fmmodule.c $(GLHACK) -lfm -lgl		# Font Manager
+#sgi sgimodule.c			# sgi.nap() and a few more
+
+# This module requires the header file
+# /usr/people/4Dgifts/iristools/include/izoom.h:
+#imgfile imgfile.c -limage -lgutil -lgl -lm	# Image Processing Utilities
+
+
+# These modules require the Multimedia Development Option (I think):
+
+#al almodule.c -laudio			# Audio Library
+#cd cdmodule.c -lcdaudio -lds -lmediad	# CD Audio Library
+#cl clmodule.c -lcl -lawareaudio	# Compression Library
+#sv svmodule.c yuvconvert.c -lsvideo -lXext -lX11	# Starter Video
+
+
+# The FORMS library, by Mark Overmars, implements user interface
+# components such as dialogs and buttons using SGI's GL and FM
+# libraries.  You must ftp the FORMS library separately from
+# ftp://ftp.cs.ruu.nl/pub/SGI/FORMS.  It was tested with FORMS 2.2a.
+# NOTE: if you want to be able to use FORMS and curses simultaneously
+# (or both link them statically into the same binary), you must
+# compile all of FORMS with the cc option "-Dclear=__GLclear".
+
+# The FORMS variable must point to the FORMS subdirectory of the forms
+# toplevel directory:
+
+#FORMS=/ufs/guido/src/forms/FORMS
+#fl flmodule.c -I$(FORMS) $(GLHACK) $(FORMS)/libforms.a -lfm -lgl
+
+
+# SunOS specific modules -- off by default:
+
+#sunaudiodev sunaudiodev.c
+
+
+# A Linux specific module -- off by default; this may also work on 
+# some *BSDs.
+
+#linuxaudiodev linuxaudiodev.c
+
+
+# George Neville-Neil's timing module:
+
+#timing timingmodule.c
+
+
+# The _tkinter module.
+#
+# The command for _tkinter is long and site specific.  Please
+# uncomment and/or edit those parts as indicated.  If you don't have a
+# specific extension (e.g. Tix or BLT), leave the corresponding line
+# commented out.  (Leave the trailing backslashes in!  If you
+# experience strange errors, you may want to join all uncommented
+# lines and remove the backslashes -- the backslash interpretation is
+# done by the shell's "read" command and it may not be implemented on
+# every system.
+
+# *** Always uncomment this (leave the leading underscore in!):
+# _tkinter _tkinter.c tkappinit.c -DWITH_APPINIT \
+# *** Uncomment and edit to reflect where your Tcl/Tk libraries are:
+#	-L/usr/local/lib \
+# *** Uncomment and edit to reflect where your Tcl/Tk headers are:
+#	-I/usr/local/include \
+# *** Uncomment and edit to reflect where your X11 header files are:
+#	-I/usr/X11R6/include \
+# *** Or uncomment this for Solaris:
+#	-I/usr/openwin/include \
+# *** Uncomment and edit for Tix extension only:
+#	-DWITH_TIX -ltix8.1.8.2 \
+# *** Uncomment and edit for BLT extension only:
+#	-DWITH_BLT -I/usr/local/blt/blt8.0-unoff/include -lBLT8.0 \
+# *** Uncomment and edit for PIL (TkImaging) extension only:
+#     (See http://www.pythonware.com/products/pil/ for more info)
+#	-DWITH_PIL -I../Extensions/Imaging/libImaging  tkImaging.c \
+# *** Uncomment and edit for TOGL extension only:
+#	-DWITH_TOGL togl.c \
+# *** Uncomment and edit to reflect your Tcl/Tk versions:
+#	-ltk8.2 -ltcl8.2 \
+# *** Uncomment and edit to reflect where your X11 libraries are:
+#	-L/usr/X11R6/lib \
+# *** Or uncomment this for Solaris:
+#	-L/usr/openwin/lib \
+# *** Uncomment these for TOGL extension only:
+#	-lGL -lGLU -lXext -lXmu \
+# *** Uncomment for AIX:
+#	-lld \
+# *** Always uncomment this; X11 libraries to link with:
+#	-lX11
+
+# Lance Ellinghaus's syslog module
+#syslog syslogmodule.c		# syslog daemon interface
+
+
+# Curses support, requring the System V version of curses, often
+# provided by the ncurses library.  e.g. on Linux, link with -lncurses
+# instead of -lcurses).
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#_curses _cursesmodule.c -lcurses -ltermcap
+# Wrapper for the panel library that's part of ncurses and SYSV curses.
+#_curses_panel _curses_panel.c -lpanel -lncurses 
+
+
+# Generic (SunOS / SVR4) dynamic loading module.
+# This is not needed for dynamic loading of Python modules --
+# it is a highly experimental and dangerous device for calling
+# *arbitrary* C functions in *arbitrary* shared libraries:
+
+#dl dlmodule.c
+
+
+# Modules that provide persistent dictionary-like semantics.  You will
+# probably want to arrange for at least one of them to be available on
+# your machine, though none are defined by default because of library
+# dependencies.  The Python module anydbm.py provides an
+# implementation independent wrapper for these; dumbdbm.py provides
+# similar functionality (but slower of course) implemented in Python.
+
+# The standard Unix dbm module has been moved to Setup.config so that
+# it will be compiled as a shared library by default.  Compiling it as
+# a built-in module causes conflicts with the pybsddb3 module since it
+# creates a static dependency on an out-of-date version of db.so.
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#dbm dbmmodule.c 	# dbm(3) may require -lndbm or similar
+
+# Anthony Baxter's gdbm module.  GNU dbm(3) will require -lgdbm:
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#gdbm gdbmmodule.c -I/usr/local/include -L/usr/local/lib -lgdbm
+
+
+# Sleepycat Berkeley DB interface.
+#
+# This requires the Sleepycat DB code, see http://www.sleepycat.com/
+# The earliest supported version of that library is 3.0, the latest
+# supported version is 4.0 (4.1 is specifically not supported, as that
+# changes the semantics of transactional databases). A list of available
+# releases can be found at
+#
+# http://www.sleepycat.com/update/index.html
+#
+# Edit the variables DB and DBLIBVERto point to the db top directory
+# and the subdirectory of PORT where you built it.
+#DB=/usr/local/BerkeleyDB.4.0
+#DBLIBVER=4.0
+#DBINC=$(DB)/include
+#DBLIB=$(DB)/lib
+#_bsddb _bsddb.c -I$(DBINC) -L$(DBLIB) -ldb-$(DBLIBVER)
+
+# Historical Berkeley DB 1.85
+#
+# This module is deprecated; the 1.85 version of the Berkeley DB library has
+# bugs that can cause data corruption. If you can, use later versions of the
+# library instead, available from <http://www.sleepycat.com/>.
+
+#DB=/depot/sundry/src/berkeley-db/db.1.85
+#DBPORT=$(DB)/PORT/irix.5.3
+#bsddb185 bsddbmodule.c -I$(DBPORT)/include -I$(DBPORT) $(DBPORT)/libdb.a
+
+
+
+# Helper module for various ascii-encoders
+#binascii binascii.c
+
+# Fred Drake's interface to the Python parser
+#parser parsermodule.c
+
+# cStringIO and cPickle
+#cStringIO cStringIO.c
+#cPickle cPickle.c
+
+
+# Lee Busby's SIGFPE modules.
+# The library to link fpectl with is platform specific.
+# Choose *one* of the options below for fpectl:
+
+# For SGI IRIX (tested on 5.3):
+#fpectl fpectlmodule.c -lfpe
+
+# For Solaris with SunPro compiler (tested on Solaris 2.5 with SunPro C 4.2):
+# (Without the compiler you don't have -lsunmath.)
+#fpectl fpectlmodule.c -R/opt/SUNWspro/lib -lsunmath -lm
+
+# For other systems: see instructions in fpectlmodule.c.
+#fpectl fpectlmodule.c ...
+
+# Test module for fpectl.  No extra libraries needed.
+#fpetest fpetestmodule.c
+
+# Andrew Kuchling's zlib module.
+# This require zlib 1.1.3 (or later).
+# See http://www.gzip.org/zlib/
+#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz
+
+# Interface to the Expat XML parser
+#
+# Expat was written by James Clark and is now maintained by a group of
+# developers on SourceForge; see www.libexpat.org for more
+# information.  The pyexpat module was written by Paul Prescod after a
+# prototype by Jack Jansen.  Source of Expat 1.95.2 is included in
+# Modules/expat/.  Usage of a system shared libexpat.so/expat.dll is
+# not advised.
+#
+# More information on Expat can be found at www.libexpat.org.
+#
+#pyexpat expat/xmlparse.c expat/xmlrole.c expat/xmltok.c pyexpat.c -I$(srcdir)/Modules/expat -DHAVE_EXPAT_CONFIG_H -DUSE_PYEXPAT_CAPI
+
+
+# Hye-Shik Chang's CJKCodecs
+
+# multibytecodec is required for all the other CJK codec modules
+#_multibytecodec cjkcodecs/multibytecodec.c
+
+#_codecs_cn cjkcodecs/_codecs_cn.c
+#_codecs_hk cjkcodecs/_codecs_hk.c
+#_codecs_iso2022 cjkcodecs/_codecs_iso2022.c
+#_codecs_jp cjkcodecs/_codecs_jp.c
+#_codecs_kr cjkcodecs/_codecs_kr.c
+#_codecs_tw cjkcodecs/_codecs_tw.c
+
+# Example -- included for reference only:
+# xx xxmodule.c
+
+# Another example -- the 'xxsubtype' module shows C-level subtyping in action
+xxsubtype xxsubtype.c
diff -Naur Python-2.7.13/Modules/Setup.config ../Python-2.7.13/Modules/Setup.config
--- Python-2.7.13/Modules/Setup.config	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/Setup.config	2017-07-04 15:04:11.000000000 +0200
@@ -0,0 +1,13 @@
+# This file is transmogrified into Setup.config by config.status.
+
+# The purpose of this file is to conditionally enable certain modules
+# based on configure-time options.
+
+# Threading
+thread threadmodule.c
+
+# The signal module
+signal signalmodule.c
+
+# The rest of the modules previously listed in this file are built
+# by the setup.py script in Python 2.1 and later.
diff -Naur Python-2.7.13/Modules/Setup.dist ../Python-2.7.13/Modules/Setup.dist
--- Python-2.7.13/Modules/Setup.dist	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/Setup.dist	2017-07-04 13:41:55.000000000 +0200
@@ -215,10 +215,10 @@
 
 # Socket module helper for SSL support; you must comment out the other
 # socket line above, and possibly edit the SSL variable:
-#SSL=/usr/local/ssl
-#_ssl _ssl.c \
-#	-DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \
-#	-L$(SSL)/lib -lssl -lcrypto
+SSL=../blink/Frameworks
+_ssl _ssl.c \
+	-DUSE_SSL -I$(SSL)/include \
+	-F$(SSL) -Framework openssl -lcrypto
 
 # The crypt module is now disabled by default because it breaks builds
 # on many systems (where -lcrypt is needed), e.g. Linux (I believe).
diff -Naur Python-2.7.13/Modules/Setup.local ../Python-2.7.13/Modules/Setup.local
--- Python-2.7.13/Modules/Setup.local	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/Setup.local	2017-07-04 15:04:11.000000000 +0200
@@ -0,0 +1 @@
+# Edit this file for local setup changes
diff -Naur Python-2.7.13/Modules/config.c ../Python-2.7.13/Modules/config.c
--- Python-2.7.13/Modules/config.c	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/config.c	2017-07-08 21:44:35.000000000 +0200
@@ -0,0 +1,187 @@
+/* Generated automatically from ./Modules/config.c.in by makesetup. */
+/* -*- C -*- ***********************************************
+Copyright (c) 2000, BeOpen.com.
+Copyright (c) 1995-2000, Corporation for National Research Initiatives.
+Copyright (c) 1990-1995, Stichting Mathematisch Centrum.
+All rights reserved.
+
+See the file "Misc/COPYRIGHT" for information on usage and
+redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+******************************************************************/
+
+/* Module configuration */
+
+/* !!! !!! !!! This file is edited by the makesetup script !!! !!! !!! */
+// iOS: edited by hand, because cross-compilation //
+// Missing: openssl module (ssl is there)
+
+/* This file contains the table of built-in modules.
+   See init_builtin() in import.c. */
+
+#include "Python.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void initarray(void);
+extern void initbinascii(void);
+extern void initcmath(void);
+extern void initfuture_builtins(void);
+extern void initmath(void);
+extern void init_md5(void);
+extern void initnt(void);
+extern void initoperator(void);
+extern void initstrop(void);
+extern void inittime(void);
+extern void initthread(void);
+
+extern void init_hashlib(void); 
+extern void init_sha(void);
+extern void init_sha256(void);
+extern void init_sha512(void);
+extern void init_locale(void);
+extern void init_socket(void);
+extern void initsyslog(void);
+extern void initgrp(void);
+extern void initfcntl(void);
+extern void initcrypt(void);
+extern void initselect(void);
+extern void initpyexpat(void);
+extern void init_ctypes(void);
+extern void initunicodedata(void);
+extern void initbz2(void);
+    
+extern void initsignal(void);
+extern void initposix(void);
+extern void initerrno(void);
+extern void initpwd(void);
+extern void init_sre(void);
+extern void init_codecs(void);
+extern void init_weakref(void);
+extern void initzipimport(void);
+extern void init_symtable(void);
+extern void init_ssl(void);
+extern void initxxsubtype(void);
+
+extern void initcStringIO(void);
+extern void initcPickle(void);
+extern void init_hotshot(void);
+extern void init_random(void);
+extern void inititertools(void);
+extern void init_collections(void);
+extern void init_heapq(void);
+extern void init_bisect(void);
+extern void initmmap(void);
+extern void init_csv(void);
+extern void initparser(void);
+extern void init_struct(void);
+extern void initdatetime(void);
+extern void init_functools(void);
+extern void init_json(void);
+extern void initzlib(void);
+
+extern void init_lsprof(void);
+extern void init_io(void);
+
+
+/* -- ADDMODULE MARKER 1 -- */
+
+extern void PyMarshal_Init(void);
+extern void initimp(void);
+extern void initgc(void);
+extern void init_ast(void);
+extern void _PyWarnings_Init(void);
+
+struct _inittab _PyImport_Inittab[] = {
+    {"array", initarray},
+    {"binascii", initbinascii},
+    {"cmath", initcmath},
+    {"future_builtins", initfuture_builtins},
+    {"math", initmath},
+    {"_md5", init_md5},
+    {"operator", initoperator},
+    {"strop", initstrop},
+    {"time", inittime},
+
+	{"_hash", init_hashlib}, 
+    {"_sha", init_sha},
+    {"_sha256", init_sha256},
+    {"_sha512", init_sha512},
+    {"_locale", init_locale},    
+    {"_socket", init_socket},   
+	{"syslog", initsyslog},
+	{"grp", initgrp},
+	{"fcntl", initfcntl}, 
+	{"crypt", initcrypt},
+	{"select", initselect},
+	{"pyexpat", initpyexpat},
+    {"_ctypes", init_ctypes},
+    {"unicodedata", initunicodedata},
+    {"bz2", initbz2},
+    
+	{"thread", initthread},
+	{"signal", initsignal},
+	{"posix", initposix},
+    {"cStringIO", initcStringIO},
+    {"cPickle", initcPickle},
+
+    {"_hotshot", init_hotshot},
+    {"_random", init_random},
+    {"_bisect", init_bisect},
+    {"_heapq", init_heapq},
+    {"_lsprof", init_lsprof},
+    {"itertools", inititertools},
+    {"_collections", init_collections},
+    {"mmap", initmmap},
+    {"_csv", init_csv},
+    {"parser", initparser},
+    {"_struct", init_struct},
+    {"datetime", initdatetime},
+    {"_functools", init_functools},
+    {"_json", init_json},
+
+    {"zlib", initzlib},
+	
+	{"errno", initerrno},
+	{"pwd", initpwd},
+	{"_sre", init_sre},
+	{"_codecs", init_codecs},
+	{"_weakref", init_weakref},
+	{"zipimport", initzipimport},
+	{"_symtable", init_symtable},
+	{"_ssl", init_ssl},
+	{"xxsubtype", initxxsubtype},
+
+/* -- ADDMODULE MARKER 2 -- */
+
+    /* This module lives in marshal.c */
+    {"marshal", PyMarshal_Init},
+
+    /* This lives in import.c */
+    {"imp", initimp},
+
+    /* This lives in Python/Python-ast.c */
+    {"_ast", init_ast},
+
+    /* These entries are here for sys.builtin_module_names */
+    {"__main__", NULL},
+    {"__builtin__", NULL},
+    {"sys", NULL},
+    {"exceptions", NULL},
+    {"_io", init_io},
+
+    /* This lives in gcmodule.c */
+    {"gc", initgc},
+
+    /* This lives in _warnings.c */
+    {"_warnings", _PyWarnings_Init},
+
+    /* Sentinel */
+    {0, 0}
+};
+
+
+#ifdef __cplusplus
+}
+#endif
diff -Naur Python-2.7.13/Modules/config_sharedlibs.c ../Python-2.7.13/Modules/config_sharedlibs.c
--- Python-2.7.13/Modules/config_sharedlibs.c	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/config_sharedlibs.c	2017-07-08 00:25:03.000000000 +0200
@@ -0,0 +1,97 @@
+/* Generated automatically from ./Modules/config.c.in by makesetup. */
+/* -*- C -*- ***********************************************
+Copyright (c) 2000, BeOpen.com.
+Copyright (c) 1995-2000, Corporation for National Research Initiatives.
+Copyright (c) 1990-1995, Stichting Mathematisch Centrum.
+All rights reserved.
+
+See the file "Misc/COPYRIGHT" for information on usage and
+redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+******************************************************************/
+
+/* Module configuration */
+
+/* !!! !!! !!! This file is edited by the makesetup script !!! !!! !!! */
+
+/* This file contains the table of built-in modules.
+   See init_builtin() in import.c. */
+
+#include "Python.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern void initthread(void);
+extern void initsignal(void);
+extern void initposix(void);
+extern void initerrno(void);
+extern void initpwd(void);
+extern void init_sre(void);
+extern void init_codecs(void);
+extern void init_weakref(void);
+extern void initzipimport(void);
+extern void init_symtable(void);
+extern void init_ssl(void);
+// extern void initopenssl(void);
+extern void SSL_library_init(void);
+extern void initxxsubtype(void);
+
+/* -- ADDMODULE MARKER 1 -- */
+
+extern void PyMarshal_Init(void);
+extern void initimp(void);
+extern void initgc(void);
+extern void init_ast(void);
+extern void _PyWarnings_Init(void);
+
+struct _inittab _PyImport_Inittab[] = {
+
+	{"thread", initthread},
+	{"signal", initsignal},
+	{"posix", initposix},
+	{"errno", initerrno},
+	{"pwd", initpwd},
+	{"_sre", init_sre},
+	{"_codecs", init_codecs},
+	{"_weakref", init_weakref},
+	{"zipimport", initzipimport},
+	{"_symtable", init_symtable},
+	{"_ssl", init_ssl},
+    // ??? iOS
+	// {"openssl", initopenssl},
+    {"openssl", SSL_library_init},
+	{"xxsubtype", initxxsubtype},
+
+/* -- ADDMODULE MARKER 2 -- */
+
+    /* This module lives in marshal.c */
+    {"marshal", PyMarshal_Init},
+
+    /* This lives in import.c */
+    {"imp", initimp},
+
+    /* This lives in Python/Python-ast.c */
+    {"_ast", init_ast},
+
+    /* These entries are here for sys.builtin_module_names */
+    {"__main__", NULL},
+    {"__builtin__", NULL},
+    {"sys", NULL},
+    {"exceptions", NULL},
+
+    /* This lives in gcmodule.c */
+    {"gc", initgc},
+
+    /* This lives in _warnings.c */
+    {"_warnings", _PyWarnings_Init},
+
+    /* Sentinel */
+    {0, 0}
+};
+
+
+#ifdef __cplusplus
+}
+#endif
diff -Naur Python-2.7.13/Modules/expat/xmlparse.c ../Python-2.7.13/Modules/expat/xmlparse.c
--- Python-2.7.13/Modules/expat/xmlparse.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/expat/xmlparse.c	2017-07-08 11:57:01.000000000 +0200
@@ -13,7 +13,7 @@
 #elif defined(__WATCOMC__)
 #include "watcomconfig.h"
 #elif defined(HAVE_EXPAT_CONFIG_H)
-#include <expat_config.h>
+#include "expat_config.h"
 #endif /* ndef COMPILED_FROM_DSP */
 
 #include <stddef.h>
diff -Naur Python-2.7.13/Modules/expat/xmlrole.c ../Python-2.7.13/Modules/expat/xmlrole.c
--- Python-2.7.13/Modules/expat/xmlrole.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/expat/xmlrole.c	2017-07-08 14:48:04.000000000 +0200
@@ -14,7 +14,7 @@
 #include "watcomconfig.h"
 #else
 #ifdef HAVE_EXPAT_CONFIG_H
-#include <expat_config.h>
+#include "expat_config.h"
 #endif
 #endif /* ndef COMPILED_FROM_DSP */
 
diff -Naur Python-2.7.13/Modules/expat/xmltok.c ../Python-2.7.13/Modules/expat/xmltok.c
--- Python-2.7.13/Modules/expat/xmltok.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/expat/xmltok.c	2017-07-08 14:48:10.000000000 +0200
@@ -14,7 +14,7 @@
 #include "watcomconfig.h"
 #else
 #ifdef HAVE_EXPAT_CONFIG_H
-#include <expat_config.h>
+#include "expat_config.h"
 #endif
 #endif /* ndef COMPILED_FROM_DSP */
 
diff -Naur Python-2.7.13/Modules/gcmodule.c ../Python-2.7.13/Modules/gcmodule.c
--- Python-2.7.13/Modules/gcmodule.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/gcmodule.c	2017-11-04 23:35:16.000000000 +0100
@@ -1437,7 +1437,7 @@
         n = 0; /* already collecting, don't do anything */
     else {
         collecting = 1;
-        n = collect(NUM_GENERATIONS - 1);
+        n = collect(NUM_GENERATIONS - 1); // That's the one throwing the exception?
         collecting = 0;
     }
 
diff -Naur Python-2.7.13/Modules/getpath.c ../Python-2.7.13/Modules/getpath.c
--- Python-2.7.13/Modules/getpath.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/getpath.c	2017-07-18 21:23:48.000000000 +0200
@@ -448,9 +448,14 @@
         ** which is in the framework, not relative to the executable, which may
         ** be outside of the framework. Except when we're in the build directory...
         */
-    pythonModule = NSModuleForSymbol(NSLookupAndBindSymbol("_Py_Initialize"));
+    /* On iOS, special case of the special case: all these functions are unavailable.
+       But we *know* we are in a framework */
+    // pythonModule = NSModuleForSymbol(NSLookupAndBindSymbol("_Py_Initialize"));
     /* Use dylib functions to find out where the framework was loaded from */
-    buf = (char *)NSLibraryNameForModule(pythonModule);
+    // buf = (char *)NSLibraryNameForModule(pythonModule);
+    // Modules will be in the "Documents" directory
+    buf = [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] firstObject].path.UTF8String;
+    // DocumentsDirectory = ;
     if (buf != NULL) {
         /* We're in a framework. */
         /* See if we might be in the build directory. The framework in the
diff -Naur Python-2.7.13/Modules/getpath.m ../Python-2.7.13/Modules/getpath.m
--- Python-2.7.13/Modules/getpath.m	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/getpath.m	2017-07-09 21:10:20.000000000 +0200
@@ -0,0 +1,707 @@
+/* Return the initial module search path. */
+
+#include "Python.h"
+#include "osdefs.h"
+
+#include <sys/types.h>
+#include <string.h>
+
+#ifdef __APPLE__
+#include <mach-o/dyld.h>
+#import <Foundation/Foundation.h>
+#endif
+
+/* Search in some common locations for the associated Python libraries.
+ *
+ * Two directories must be found, the platform independent directory
+ * (prefix), containing the common .py and .pyc files, and the platform
+ * dependent directory (exec_prefix), containing the shared library
+ * modules.  Note that prefix and exec_prefix can be the same directory,
+ * but for some installations, they are different.
+ *
+ * Py_GetPath() carries out separate searches for prefix and exec_prefix.
+ * Each search tries a number of different locations until a ``landmark''
+ * file or directory is found.  If no prefix or exec_prefix is found, a
+ * warning message is issued and the preprocessor defined PREFIX and
+ * EXEC_PREFIX are used (even though they will not work); python carries on
+ * as best as is possible, but most imports will fail.
+ *
+ * Before any searches are done, the location of the executable is
+ * determined.  If argv[0] has one or more slashes in it, it is used
+ * unchanged.  Otherwise, it must have been invoked from the shell's path,
+ * so we search $PATH for the named executable and use that.  If the
+ * executable was not found on $PATH (or there was no $PATH environment
+ * variable), the original argv[0] string is used.
+ *
+ * Next, the executable location is examined to see if it is a symbolic
+ * link.  If so, the link is chased (correctly interpreting a relative
+ * pathname if one is found) and the directory of the link target is used.
+ *
+ * Finally, argv0_path is set to the directory containing the executable
+ * (i.e. the last component is stripped).
+ *
+ * With argv0_path in hand, we perform a number of steps.  The same steps
+ * are performed for prefix and for exec_prefix, but with a different
+ * landmark.
+ *
+ * Step 1. Are we running python out of the build directory?  This is
+ * checked by looking for a different kind of landmark relative to
+ * argv0_path.  For prefix, the landmark's path is derived from the VPATH
+ * preprocessor variable (taking into account that its value is almost, but
+ * not quite, what we need).  For exec_prefix, the landmark is
+ * Modules/Setup.  If the landmark is found, we're done.
+ *
+ * For the remaining steps, the prefix landmark will always be
+ * lib/python$VERSION/os.py and the exec_prefix will always be
+ * lib/python$VERSION/lib-dynload, where $VERSION is Python's version
+ * number as supplied by the Makefile.  Note that this means that no more
+ * build directory checking is performed; if the first step did not find
+ * the landmarks, the assumption is that python is running from an
+ * installed setup.
+ *
+ * Step 2. See if the $PYTHONHOME environment variable points to the
+ * installed location of the Python libraries.  If $PYTHONHOME is set, then
+ * it points to prefix and exec_prefix.  $PYTHONHOME can be a single
+ * directory, which is used for both, or the prefix and exec_prefix
+ * directories separated by a colon.
+ *
+ * Step 3. Try to find prefix and exec_prefix relative to argv0_path,
+ * backtracking up the path until it is exhausted.  This is the most common
+ * step to succeed.  Note that if prefix and exec_prefix are different,
+ * exec_prefix is more likely to be found; however if exec_prefix is a
+ * subdirectory of prefix, both will be found.
+ *
+ * Step 4. Search the directories pointed to by the preprocessor variables
+ * PREFIX and EXEC_PREFIX.  These are supplied by the Makefile but can be
+ * passed in as options to the configure script.
+ *
+ * That's it!
+ *
+ * Well, almost.  Once we have determined prefix and exec_prefix, the
+ * preprocessor variable PYTHONPATH is used to construct a path.  Each
+ * relative path on PYTHONPATH is prefixed with prefix.  Then the directory
+ * containing the shared library modules is appended.  The environment
+ * variable $PYTHONPATH is inserted in front of it all.  Finally, the
+ * prefix and exec_prefix globals are tweaked so they reflect the values
+ * expected by other code, by stripping the "lib/python$VERSION/..." stuff
+ * off.  If either points to the build directory, the globals are reset to
+ * the corresponding preprocessor variables (so sys.prefix will reflect the
+ * installation location, even though sys.path points into the build
+ * directory).  This seems to make more sense given that currently the only
+ * known use of sys.prefix and sys.exec_prefix is for the ILU installation
+ * process to find the installed Python tree.
+ */
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+
+#if !defined(PREFIX) || !defined(EXEC_PREFIX) || !defined(VERSION) || !defined(VPATH)
+#error "PREFIX, EXEC_PREFIX, VERSION, and VPATH must be constant defined"
+#endif
+
+#ifndef LANDMARK
+#define LANDMARK "os.py"
+#endif
+
+static char prefix[MAXPATHLEN+1];
+static char exec_prefix[MAXPATHLEN+1];
+static char progpath[MAXPATHLEN+1];
+static char *module_search_path = NULL;
+static char lib_python[] = "lib/python" VERSION;
+
+static void
+reduce(char *dir)
+{
+    size_t i = strlen(dir);
+    while (i > 0 && dir[i] != SEP)
+        --i;
+    dir[i] = '\0';
+}
+
+
+static int
+isfile(char *filename)          /* Is file, not directory */
+{
+    struct stat buf;
+    if (stat(filename, &buf) != 0)
+        return 0;
+    if (!S_ISREG(buf.st_mode))
+        return 0;
+    return 1;
+}
+
+
+static int
+ismodule(char *filename)        /* Is module -- check for .pyc/.pyo too */
+{
+    if (isfile(filename))
+        return 1;
+
+    /* Check for the compiled version of prefix. */
+    if (strlen(filename) < MAXPATHLEN) {
+        strcat(filename, Py_OptimizeFlag ? "o" : "c");
+        if (isfile(filename))
+            return 1;
+    }
+    return 0;
+}
+
+
+static int
+isxfile(char *filename)         /* Is executable file */
+{
+    struct stat buf;
+    if (stat(filename, &buf) != 0)
+        return 0;
+    if (!S_ISREG(buf.st_mode))
+        return 0;
+    if ((buf.st_mode & 0111) == 0)
+        return 0;
+    return 1;
+}
+
+
+static int
+isdir(char *filename)                   /* Is directory */
+{
+    struct stat buf;
+    if (stat(filename, &buf) != 0)
+        return 0;
+    if (!S_ISDIR(buf.st_mode))
+        return 0;
+    return 1;
+}
+
+
+/* Add a path component, by appending stuff to buffer.
+   buffer must have at least MAXPATHLEN + 1 bytes allocated, and contain a
+   NUL-terminated string with no more than MAXPATHLEN characters (not counting
+   the trailing NUL).  It's a fatal error if it contains a string longer than
+   that (callers must be careful!).  If these requirements are met, it's
+   guaranteed that buffer will still be a NUL-terminated string with no more
+   than MAXPATHLEN characters at exit.  If stuff is too long, only as much of
+   stuff as fits will be appended.
+*/
+static void
+joinpath(char *buffer, char *stuff)
+{
+    size_t n, k;
+    if (stuff[0] == SEP)
+        n = 0;
+    else {
+        n = strlen(buffer);
+        if (n > 0 && buffer[n-1] != SEP && n < MAXPATHLEN)
+            buffer[n++] = SEP;
+    }
+    if (n > MAXPATHLEN)
+        Py_FatalError("buffer overflow in getpath.c's joinpath()");
+    k = strlen(stuff);
+    if (n + k > MAXPATHLEN)
+        k = MAXPATHLEN - n;
+    strncpy(buffer+n, stuff, k);
+    buffer[n+k] = '\0';
+}
+
+/* copy_absolute requires that path be allocated at least
+   MAXPATHLEN + 1 bytes and that p be no more than MAXPATHLEN bytes. */
+static void
+copy_absolute(char *path, char *p)
+{
+    if (p[0] == SEP)
+        strcpy(path, p);
+    else {
+        if (!getcwd(path, MAXPATHLEN)) {
+            /* unable to get the current directory */
+            strcpy(path, p);
+            return;
+        }
+        if (p[0] == '.' && p[1] == SEP)
+            p += 2;
+        joinpath(path, p);
+    }
+}
+
+/* absolutize() requires that path be allocated at least MAXPATHLEN+1 bytes. */
+static void
+absolutize(char *path)
+{
+    char buffer[MAXPATHLEN + 1];
+
+    if (path[0] == SEP)
+        return;
+    copy_absolute(buffer, path);
+    strcpy(path, buffer);
+}
+
+/* search_for_prefix requires that argv0_path be no more than MAXPATHLEN
+   bytes long.
+*/
+static int
+search_for_prefix(char *argv0_path, char *home)
+{
+    size_t n;
+    char *vpath;
+
+    /* If PYTHONHOME is set, we believe it unconditionally */
+    if (home) {
+        char *delim;
+        strncpy(prefix, home, MAXPATHLEN);
+        delim = strchr(prefix, DELIM);
+        if (delim)
+            *delim = '\0';
+        joinpath(prefix, lib_python);
+        joinpath(prefix, LANDMARK);
+        return 1;
+    }
+
+    /* Check to see if argv[0] is in the build directory */
+    strcpy(prefix, argv0_path);
+    joinpath(prefix, "Modules/Setup");
+    if (isfile(prefix)) {
+        /* Check VPATH to see if argv0_path is in the build directory. */
+        vpath = VPATH;
+        strcpy(prefix, argv0_path);
+        joinpath(prefix, vpath);
+        joinpath(prefix, "Lib");
+        joinpath(prefix, LANDMARK);
+        if (ismodule(prefix))
+            return -1;
+    }
+
+    /* Search from argv0_path, until root is found */
+    copy_absolute(prefix, argv0_path);
+    do {
+        n = strlen(prefix);
+        joinpath(prefix, lib_python);
+        joinpath(prefix, LANDMARK);
+        if (ismodule(prefix))
+            return 1;
+        prefix[n] = '\0';
+        reduce(prefix);
+    } while (prefix[0]);
+
+    /* Look at configure's PREFIX */
+    strncpy(prefix, PREFIX, MAXPATHLEN);
+    joinpath(prefix, lib_python);
+    joinpath(prefix, LANDMARK);
+    if (ismodule(prefix))
+        return 1;
+
+    /* Fail */
+    return 0;
+}
+
+
+/* search_for_exec_prefix requires that argv0_path be no more than
+   MAXPATHLEN bytes long.
+*/
+static int
+search_for_exec_prefix(char *argv0_path, char *home)
+{
+    size_t n;
+
+    /* If PYTHONHOME is set, we believe it unconditionally */
+    if (home) {
+        char *delim;
+        delim = strchr(home, DELIM);
+        if (delim)
+            strncpy(exec_prefix, delim+1, MAXPATHLEN);
+        else
+            strncpy(exec_prefix, home, MAXPATHLEN);
+        joinpath(exec_prefix, lib_python);
+        joinpath(exec_prefix, "lib-dynload");
+        return 1;
+    }
+
+    /* Check to see if argv[0] is in the build directory. "pybuilddir.txt"
+       is written by setup.py and contains the relative path to the location
+       of shared library modules. */
+    strcpy(exec_prefix, argv0_path);
+    joinpath(exec_prefix, "pybuilddir.txt");
+    if (isfile(exec_prefix)) {
+      FILE *f = fopen(exec_prefix, "r");
+      if (f == NULL)
+	errno = 0;
+      else {
+	char rel_builddir_path[MAXPATHLEN+1];
+	size_t n;
+	n = fread(rel_builddir_path, 1, MAXPATHLEN, f);
+	rel_builddir_path[n] = '\0';
+	fclose(f);
+	strcpy(exec_prefix, argv0_path);
+	joinpath(exec_prefix, rel_builddir_path);
+	return -1;
+      }
+    }
+
+    /* Search from argv0_path, until root is found */
+    copy_absolute(exec_prefix, argv0_path);
+    do {
+        n = strlen(exec_prefix);
+        joinpath(exec_prefix, lib_python);
+        joinpath(exec_prefix, "lib-dynload");
+        if (isdir(exec_prefix))
+            return 1;
+        exec_prefix[n] = '\0';
+        reduce(exec_prefix);
+    } while (exec_prefix[0]);
+
+    /* Look at configure's EXEC_PREFIX */
+    strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+    joinpath(exec_prefix, lib_python);
+    joinpath(exec_prefix, "lib-dynload");
+    if (isdir(exec_prefix))
+        return 1;
+
+    /* Fail */
+    return 0;
+}
+
+
+static void
+calculate_path(void)
+{
+    extern char *Py_GetProgramName(void);
+
+    static char delimiter[2] = {DELIM, '\0'};
+    static char separator[2] = {SEP, '\0'};
+    char *pythonpath = PYTHONPATH;
+    char *rtpypath = Py_GETENV("PYTHONPATH");
+    char *home = Py_GetPythonHome();
+    char *path = getenv("PATH");
+    char *prog = Py_GetProgramName();
+    char argv0_path[MAXPATHLEN+1];
+    char zip_path[MAXPATHLEN+1];
+    int pfound, efound; /* 1 if found; -1 if found build directory */
+    char *buf;
+    size_t bufsz;
+    size_t prefixsz;
+    char *defpath = pythonpath;
+    
+#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
+    // A bit extreme, but the sandbox is really limiting 
+    char *iospath = Py_GETENV("PYTHONHOME");
+    sprintf(progpath, "%s/bin/%s", iospath, prog);
+#else
+    
+#ifdef WITH_NEXT_FRAMEWORK
+    NSModule pythonModule;
+#endif
+#ifdef __APPLE__
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
+    uint32_t nsexeclength = MAXPATHLEN;
+#else
+    unsigned long nsexeclength = MAXPATHLEN;
+#endif
+#endif
+
+        /* If there is no slash in the argv0 path, then we have to
+         * assume python is on the user's $PATH, since there's no
+         * other way to find a directory to start the search from.  If
+         * $PATH isn't exported, you lose.
+         */
+        if (strchr(prog, SEP))
+                strncpy(progpath, prog, MAXPATHLEN);
+#ifdef __APPLE__
+    
+     /* On Mac OS X, if a script uses an interpreter of the form
+      * "#!/opt/python2.3/bin/python", the kernel only passes "python"
+      * as argv[0], which falls through to the $PATH search below.
+      * If /opt/python2.3/bin isn't in your path, or is near the end,
+      * this algorithm may incorrectly find /usr/bin/python. To work
+      * around this, we can use _NSGetExecutablePath to get a better
+      * hint of what the intended interpreter was, although this
+      * will fail if a relative path was used. but in that case,
+      * absolutize() should help us out below
+      */
+    // Doesn't apply on an iPhone, though, since _NSGetExecutablePath gives the parent app
+     else if(0 == _NSGetExecutablePath(progpath, &nsexeclength) && progpath[0] == SEP)
+       ;
+#endif /* __APPLE__ */
+        else if (path) {
+                while (1) {
+                        char *delim = strchr(path, DELIM);
+
+                        if (delim) {
+                                size_t len = delim - path;
+                                if (len > MAXPATHLEN)
+                                        len = MAXPATHLEN;
+                                strncpy(progpath, path, len);
+                                *(progpath + len) = '\0';
+                        }
+                        else
+                                strncpy(progpath, path, MAXPATHLEN);
+
+                        joinpath(progpath, prog);
+                        if (isxfile(progpath))
+                                break;
+
+                        if (!delim) {
+                                progpath[0] = '\0';
+                                break;
+                        }
+                        path = delim + 1;
+                }
+        }
+        else
+                progpath[0] = '\0';
+#endif //__IPHONE_OS_VERSION_MAX_ALLOWED
+        if (progpath[0] != SEP && progpath[0] != '\0')
+                absolutize(progpath);
+        strncpy(argv0_path, progpath, MAXPATHLEN);
+        argv0_path[MAXPATHLEN] = '\0';
+
+#ifdef WITH_NEXT_FRAMEWORK
+        /* On Mac OS X we have a special case if we're running from a framework.
+        ** This is because the python home should be set relative to the library,
+        ** which is in the framework, not relative to the executable, which may
+        ** be outside of the framework. Except when we're in the build directory...
+        */
+    /* On iOS, special case of the special case: all these functions are unavailable.
+       But we *know* we are in a framework */
+    pythonModule = NSModuleForSymbol(NSLookupAndBindSymbol("_Py_Initialize"));
+    /* Use dylib functions to find out where the framework was loaded from */
+    buf = (char *)NSLibraryNameForModule(pythonModule).path.UTF8String;
+    // DocumentsDirectory = ;
+    if (buf != NULL) {
+        /* We're in a framework. */
+        /* See if we might be in the build directory. The framework in the
+        ** build directory is incomplete, it only has the .dylib and a few
+        ** needed symlinks, it doesn't have the Lib directories and such.
+        ** If we're running with the framework from the build directory we must
+        ** be running the interpreter in the build directory, so we use the
+        ** build-directory-specific logic to find Lib and such.
+        */
+        strncpy(argv0_path, buf, MAXPATHLEN);
+        reduce(argv0_path);
+        joinpath(argv0_path, lib_python);
+        joinpath(argv0_path, LANDMARK);
+        if (!ismodule(argv0_path)) {
+                /* We are in the build directory so use the name of the
+                   executable - we know that the absolute path is passed */
+                strncpy(argv0_path, progpath, MAXPATHLEN);
+        }
+        else {
+                /* Use the location of the library as the progpath */
+                strncpy(argv0_path, buf, MAXPATHLEN);
+        }
+    }
+#endif
+
+#if HAVE_READLINK
+    {
+        char tmpbuffer[MAXPATHLEN+1];
+        int linklen = readlink(progpath, tmpbuffer, MAXPATHLEN);
+        while (linklen != -1) {
+            /* It's not null terminated! */
+            tmpbuffer[linklen] = '\0';
+            if (tmpbuffer[0] == SEP)
+                /* tmpbuffer should never be longer than MAXPATHLEN,
+                   but extra check does not hurt */
+                strncpy(argv0_path, tmpbuffer, MAXPATHLEN);
+            else {
+                /* Interpret relative to progpath */
+                reduce(argv0_path);
+                joinpath(argv0_path, tmpbuffer);
+            }
+            linklen = readlink(argv0_path, tmpbuffer, MAXPATHLEN);
+        }
+    }
+#endif /* HAVE_READLINK */
+
+    reduce(argv0_path);
+    /* At this point, argv0_path is guaranteed to be less than
+       MAXPATHLEN bytes long.
+    */
+
+    if (!(pfound = search_for_prefix(argv0_path, home))) {
+        if (!Py_FrozenFlag)
+            fprintf(stderr,
+                "Could not find platform independent libraries <prefix>\n");
+        strncpy(prefix, PREFIX, MAXPATHLEN);
+        joinpath(prefix, lib_python);
+    }
+    else
+        reduce(prefix);
+
+    strncpy(zip_path, prefix, MAXPATHLEN);
+    zip_path[MAXPATHLEN] = '\0';
+    if (pfound > 0) { /* Use the reduced prefix returned by Py_GetPrefix() */
+        reduce(zip_path);
+        reduce(zip_path);
+    }
+    else
+        strncpy(zip_path, PREFIX, MAXPATHLEN);
+    joinpath(zip_path, "lib/python00.zip");
+    bufsz = strlen(zip_path);   /* Replace "00" with version */
+    zip_path[bufsz - 6] = VERSION[0];
+    zip_path[bufsz - 5] = VERSION[2];
+
+    if (!(efound = search_for_exec_prefix(argv0_path, home))) {
+        if (!Py_FrozenFlag)
+            fprintf(stderr,
+                "Could not find platform dependent libraries <exec_prefix>\n");
+        strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+        joinpath(exec_prefix, "lib/lib-dynload");
+    }
+    /* If we found EXEC_PREFIX do *not* reduce it!  (Yet.) */
+
+    if ((!pfound || !efound) && !Py_FrozenFlag)
+        fprintf(stderr,
+                "Consider setting $PYTHONHOME to <prefix>[:<exec_prefix>]\n");
+
+    /* Calculate size of return buffer.
+     */
+    bufsz = 0;
+
+    if (rtpypath)
+        bufsz += strlen(rtpypath) + 1;
+
+    prefixsz = strlen(prefix) + 1;
+
+    while (1) {
+        char *delim = strchr(defpath, DELIM);
+
+        if (defpath[0] != SEP)
+            /* Paths are relative to prefix */
+            bufsz += prefixsz;
+
+        if (delim)
+            bufsz += delim - defpath + 1;
+        else {
+            bufsz += strlen(defpath) + 1;
+            break;
+        }
+        defpath = delim + 1;
+    }
+
+    bufsz += strlen(zip_path) + 1;
+    bufsz += strlen(exec_prefix) + 1;
+
+    /* This is the only malloc call in this file */
+    buf = (char *)PyMem_Malloc(bufsz);
+
+    if (buf == NULL) {
+        /* We can't exit, so print a warning and limp along */
+        fprintf(stderr, "Not enough memory for dynamic PYTHONPATH.\n");
+        fprintf(stderr, "Using default static PYTHONPATH.\n");
+        module_search_path = PYTHONPATH;
+    }
+    else {
+        /* Run-time value of $PYTHONPATH goes first */
+        if (rtpypath) {
+            strcpy(buf, rtpypath);
+            strcat(buf, delimiter);
+        }
+        else
+            buf[0] = '\0';
+
+        /* Next is the default zip path */
+        strcat(buf, zip_path);
+        strcat(buf, delimiter);
+
+        /* Next goes merge of compile-time $PYTHONPATH with
+         * dynamically located prefix.
+         */
+        defpath = pythonpath;
+        while (1) {
+            char *delim = strchr(defpath, DELIM);
+
+            if (defpath[0] != SEP) {
+                strcat(buf, prefix);
+                if (prefixsz >= 2 && prefix[prefixsz - 2] != SEP &&
+                    defpath[0] != (delim ? DELIM : L'\0')) {  /* not empty */
+                    strcat(buf, separator);
+                }
+            }
+
+            if (delim) {
+                size_t len = delim - defpath + 1;
+                size_t end = strlen(buf) + len;
+                strncat(buf, defpath, len);
+                *(buf + end) = '\0';
+            }
+            else {
+                strcat(buf, defpath);
+                break;
+            }
+            defpath = delim + 1;
+        }
+        strcat(buf, delimiter);
+
+        /* Finally, on goes the directory for dynamic-load modules */
+        strcat(buf, exec_prefix);
+
+        /* And publish the results */
+        module_search_path = buf;
+    }
+
+    /* Reduce prefix and exec_prefix to their essence,
+     * e.g. /usr/local/lib/python1.5 is reduced to /usr/local.
+     * If we're loading relative to the build directory,
+     * return the compiled-in defaults instead.
+     */
+    if (pfound > 0) {
+        reduce(prefix);
+        reduce(prefix);
+        /* The prefix is the root directory, but reduce() chopped
+         * off the "/". */
+        if (!prefix[0])
+                strcpy(prefix, separator);
+    }
+    else
+        strncpy(prefix, PREFIX, MAXPATHLEN);
+
+    if (efound > 0) {
+        reduce(exec_prefix);
+        reduce(exec_prefix);
+        reduce(exec_prefix);
+        if (!exec_prefix[0])
+                strcpy(exec_prefix, separator);
+    }
+    else
+        strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+}
+
+
+/* External interface */
+
+char *
+Py_GetPath(void)
+{
+    if (!module_search_path)
+        calculate_path();
+    return module_search_path;
+}
+
+char *
+Py_GetPrefix(void)
+{
+    if (!module_search_path)
+        calculate_path();
+    return prefix;
+}
+
+char *
+Py_GetExecPrefix(void)
+{
+    if (!module_search_path)
+        calculate_path();
+    return exec_prefix;
+}
+
+char *
+Py_GetProgramFullPath(void)
+{
+    if (!module_search_path)
+        calculate_path();
+    return progpath;
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
diff -Naur Python-2.7.13/Modules/ld_so_aix ../Python-2.7.13/Modules/ld_so_aix
--- Python-2.7.13/Modules/ld_so_aix	1970-01-01 01:00:00.000000000 +0100
+++ ../Python-2.7.13/Modules/ld_so_aix	2017-07-04 15:04:11.000000000 +0200
@@ -0,0 +1,195 @@
+#!/bin/sh
+#
+#   ========================================================================
+#   FILE:           ld_so_aix
+#   TYPE:           executable, uses makexp_aix
+#   SYSTEM:         AIX
+#
+#   DESCRIPTION:    Creates a shareable .o from a set of pre-compiled 
+#                   (unshared) .o files
+#
+#   USAGE:          ld_so_aix [CC] [arguments]
+#
+#   ARGUMENTS:      Same as for "ld". The following arguments are processed
+#                   or supplied by this script (those marked with an asterisk
+#                   can be overridden from command line):
+#
+#                       Argument                     Default value
+#                   (*) -o [OutputFileName]          -o shr.o
+#                   (*) -e [EntryPointLabel]         -e init[OutputBaseName]
+#                   (*) -bE:[ExportFile]             -bE:[OutputBaseName].exp
+#                   (*) -bI:[ImportFile]             -bI:./python.exp
+#                       -bM:[ModuleType]             -bM:SRE
+#                       -bhalt:[Number]              -bhalt:4
+#                       -T[Number]                   -T512
+#                       -H[Number]                   -H512
+#                       -lm
+#
+#                   The compiler specific ("-lc" or "-lc_r", "-lpthreads",...)
+#                   arguments will be automatically passed to "ld" according
+#                   to the CC command provided as a first argument to this
+#                   script. Usually, the same CC command was used to produce
+#                   the pre-compiled .o file(s).
+#
+#   NOTES:          1.  Since "ld_so_aix" was originally written for building
+#                       shared modules for the Python interpreter, the -e and
+#                       -bI default values match Python's conventions. In
+#                       Python, the entry point for a shared module is based
+#                       on the module's name (e.g., the "mathmodule" will
+#                       expect an  entry point of "initmath").
+#                   2.  The script accepts multiple .o or .a input files and
+#                       creates a single (shared) output file. The export list
+#                       that is created is based on the output file's basename
+#                       with the suffix ".exp".
+#                   3.  The resulting shared object file is left in the
+#                       current directory.
+#                   4.  Uncommenting the "echo" lines gives detailed output
+#                       about the commands executed in the script.
+#
+#                       
+#   HISTORY:        Oct-1996    -- Support added for multiple .o files --
+#                               -- and optional arguments processing.  --
+#                   Chris Myers (myers@tc.cornell.edu), Keith Kwok
+#                   (kkwok@tc.cornell.edu) and Vladimir Marangozov
+#
+#                   Aug-6-1996  -- Take care of the compiler specific  --
+#                               -- args by leaving CC to invoke "ld".  --
+#                   Vladimir Marangozov
+#
+#                   Jul-1-1996  -- Make sure to use /usr/ccs/bin/ld    --
+#                               -- Use makexp_aix for the export list. --
+#                   Vladimir Marangozov     (Vladimir.Marangozov@imag.fr)
+#
+#                   Manus Hand (mhand@csn.net) -- Initial code -- 6/24/96
+#   ========================================================================
+#
+
+usage="Usage: ld_so_aix [CC command] [ld arguments]"
+if test ! -n "$*"; then
+  echo $usage; exit 2
+fi
+
+makexp=`dirname $0`/makexp_aix
+test -x "${makexp}" || makexp="/Users/holzschu/src/Xcode_iPad/Python-2.7.13/Modules/makexp_aix"
+
+# Check for existence of compiler.
+CC=$1; shift
+whichcc=`which $CC`
+
+if test ! -x "$whichcc"; then
+  echo "ld_so_aix: Compiler '$CC' not found; exiting."
+  exit 2
+fi
+
+if test ! -n "$*"; then
+  echo $usage; exit 2
+fi
+
+# Default import file for Python
+# Can be overridden by providing a -bI: argument.
+impfile="./python.exp"
+
+# Parse arguments
+while test -n "$1"
+do
+  case "$1" in
+    -e | -Wl,-e)
+        if test -z "$2"; then
+	  echo "ld_so_aix: The -e flag needs a parameter; exiting."; exit 2
+	else
+	  shift; entry=$1
+	fi
+	;;
+    -e* | -Wl,-e*)
+	entry=`echo $1 | sed -e "s/-Wl,//" -e "s/-e//"`
+	;;
+    -o)
+	if test -z "$2"; then
+	  echo "ld_so_aix: The -o flag needs a parameter; exiting."; exit 2
+	else
+	  shift; objfile=$1
+	fi
+	;;
+    -o*)
+	objfile=`echo $1 | sed "s/-o//"`
+	;;
+    -bI:* | -Wl,-bI:*)
+	impfile=`echo $1 | sed -e "s/-Wl,//" -e "s/-bI://"`
+	;;
+    -bE:* | -Wl,-bE:*)
+	expfile=`echo $1 | sed -e "s/-Wl,//" -e "s/-bE://"`
+	;;
+    *.o | *.a)
+	objs="$objs $1"
+	args="$args $1"
+	;;
+    -bM:* | -Wl,-bM:* | -H* | -Wl,-H* | -T* | -Wl,-T* | -lm)
+	;;
+    *)
+        args="$args $1"
+	;;
+  esac
+  shift
+done
+
+if test "$objfile" = "libpython2.7.so"; then
+  ldsocoremode="true" 
+fi
+
+if test -z "$objs"; then
+  echo "ld_so_aix: No input files; exiting."
+  exit 2
+elif test ! -r "$impfile" -a -z "$ldsocoremode"; then
+  echo "ld_so_aix: Import file '$impfile' not found or not readable; exiting."
+  exit 2
+fi
+
+# If -o wasn't specified, assume "-o shr.o"
+if test -z "$objfile"; then
+  objfile=shr.o
+fi
+
+filename=`basename $objfile | sed "s/\.[^.]*$//"`
+
+# If -bE: wasn't specified, assume "-bE:$filename.exp"
+if test -z "$expfile"; then
+  expfile="$filename.exp"
+fi
+
+# Default entry symbol for Python modules = init[modulename]
+# Can be overridden by providing a -e argument.
+if test -z "$entry"; then
+  entry=init`echo $filename | sed "s/module.*//"`
+fi
+
+#echo "ld_so_aix: Debug info section"
+#echo "  -> output file : $objfile"
+#echo "  -> import file : $impfile"
+#echo "  -> export file : $expfile"
+#echo "  -> entry point : $entry"
+#echo "  -> object files: $objs"
+#echo "  -> CC arguments: $args"
+
+if test -z "$ldsocoremode"; then
+  CCOPT="-Wl,-e$entry -Wl,-bE:$expfile -Wl,-bI:$impfile -Wl,-bhalt:4"
+else
+  CCOPT="-Wl,-bnoentry -Wl,-bE:$expfile -Wl,-bhalt:4"
+fi
+CCOPT="$CCOPT -Wl,-bM:SRE -Wl,-T512 -Wl,-H512 -Wl,-brtl -Wl,-bnortllib -lm -o $objfile"
+
+CCARGS="$args"
+
+# Export list generation.
+#echo $makexp $expfile "$objfile" $objs
+$makexp $expfile "$objfile" $objs
+
+# Perform the link.
+#echo $CC $CCOPT $CCARGS
+$CC $CCOPT $CCARGS
+retval=$?
+
+# Delete the module's export list file.
+# Comment this line if you need it.
+rm -f $expfile
+
+exit $retval
diff -Naur Python-2.7.13/Modules/main.c ../Python-2.7.13/Modules/main.c
--- Python-2.7.13/Modules/main.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/main.c	2017-11-24 22:46:38.000000000 +0100
@@ -8,6 +8,8 @@
 #ifdef __VMS
 #include <unixlib.h>
 #endif
+// for TARGET_OS_IPHONE
+#include "TargetConditionals.h"
 
 #if defined(MS_WINDOWS) || defined(__CYGWIN__)
 #ifdef HAVE_FCNTL_H
@@ -253,6 +255,27 @@
     int saw_unbuffered_flag = 0;
     PyCompilerFlags cf;
 
+#ifdef TARGET_OS_IPHONE
+    // initialize all flags:
+    Py_DebugFlag = 0; /* Needed by parser.c */
+    Py_VerboseFlag = 0; /* Needed by import.c */
+    Py_InteractiveFlag = 0; /* Needed by Py_FdIsInteractive() below */
+    Py_InspectFlag = 0; /* Needed to determine whether to exit at SystemExit */
+    Py_NoSiteFlag = 0; /* Suppress 'import site' */
+    Py_BytesWarningFlag = 0; /* Warn on str(bytes) and str(buffer) */
+    Py_DontWriteBytecodeFlag = 0; /* Suppress writing bytecode files (*.py[co]) */
+    Py_UseClassExceptionsFlag = 1; /* Needed by bltinmodule.c: deprecated */
+    Py_FrozenFlag = 0; /* Needed by getpath.c */
+    Py_UnicodeFlag = 0; /* Needed by compile.c */
+    Py_IgnoreEnvironmentFlag = 0; /* e.g. PYTHONPATH, PYTHONHOME */
+    /* _XXX Py_QnewFlag should go away in 2.3.  It's true iff -Qnew is passed,
+     on the command line, and is used in 2.2 by ceval.c to make all "/" divisions
+     true divisions (which they will be in 2.3). */
+    _Py_QnewFlag = 0;
+    Py_NoUserSiteDirectory = 0; /* for -s and site.py */
+    Py_HashRandomizationFlag = 0; /* for -R and PYTHONHASHSEED */
+#endif
+    
     cf.cf_flags = 0;
 
     orig_argc = argc;           /* For Py_GetArgcArgv() */
@@ -544,7 +567,12 @@
     Py_SetProgramName(argv[0]);
 #endif
     Py_Initialize();
-
+    // We couldn't Initialize, need to return before we crash.
+    if (_PyThreadState_Current == NULL) {
+        fprintf(stderr, "We could not initialize python, sorry\n"); fflush(stderr);
+        pthread_exit(NULL); 
+    }
+    
     if (Py_VerboseFlag ||
         (command == NULL && filename == NULL && module == NULL && stdin_is_interactive)) {
         fprintf(stderr, "Python %s on %s\n",
@@ -581,6 +609,7 @@
     }
 
     if (command) {
+        fflush(stderr); fflush(stdout);
         sts = PyRun_SimpleStringFlags(command, &cf) != 0;
         free(command);
     } else if (module) {
diff -Naur Python-2.7.13/Modules/posixmodule.c ../Python-2.7.13/Modules/posixmodule.c
--- Python-2.7.13/Modules/posixmodule.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/posixmodule.c	2017-11-22 22:05:55.000000000 +0100
@@ -161,7 +161,9 @@
 #endif  /* __BORLANDC__ */
 #endif  /* ! __WATCOMC__ || __QNX__ */
 #endif /* ! __IBMC__ */
-
+// iOS -- new version
+// #undef HAVE_SYSTEM
+    
 #ifndef _MSC_VER
 
 #if defined(__sgi)&&_COMPILER_VERSION>=700
@@ -349,7 +351,606 @@
 #include <sys/mkdev.h>
 #endif
 #endif
-
+    
+    
+// iOS specifics -- fork() and exec() inside a sandbox.
+#include "TargetConditionals.h"
+#ifdef TARGET_OS_IPHONE
+    
+#include <libssh2/libssh2.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <sys/poll.h>
+    
+FILE *child_stdin, *child_stdout, *child_stderr;
+    
+static int ssh_waitsocket(int socket_fd, LIBSSH2_SESSION *session) {
+    struct timeval timeout;
+    int rc;
+    fd_set fd;
+    fd_set *writefd = NULL;
+    fd_set *readfd = NULL;
+    int dir;
+    
+    timeout.tv_sec = 10;
+    timeout.tv_usec = 0;
+    
+    FD_ZERO(&fd);
+    
+    FD_SET(socket_fd, &fd);
+    
+    /* now make sure we wait in the correct direction */
+    dir = libssh2_session_block_directions(session);
+    
+    if (dir & LIBSSH2_SESSION_BLOCK_INBOUND)
+        readfd = &fd;
+    
+    if (dir & LIBSSH2_SESSION_BLOCK_OUTBOUND)
+        writefd = &fd;
+    
+    rc = select(socket_fd + 1, readfd, writefd, NULL, &timeout);
+    return rc;
+}
+    
+static int ssh_verify_host(char* addr, LIBSSH2_SESSION* _session, char* hostname, int port) {
+    LIBSSH2_KNOWNHOSTS *kh;
+    const char *key;
+    size_t key_len;
+    int key_type;
+    char *type_str;
+    
+    if (!(kh = libssh2_knownhost_init(_session))) {
+        return -1;
+    }
+    
+    // Path = getenv(SSH_HOME) or ~/Documents
+    char path[PATH_MAX];
+    if (getenv("SSH_HOME")) strcpy(path, getenv("SSH_HOME"));
+    else sprintf(path, "%s/Documents/", getenv("HOME"));
+    char khFilePath[PATH_MAX];
+    // known_hosts is shared with Blink
+    sprintf(khFilePath, "%s/known_hosts", path);
+    libssh2_knownhost_readfile(kh, khFilePath, LIBSSH2_KNOWNHOST_FILE_OPENSSH);
+    
+    key = libssh2_session_hostkey(_session, &key_len, &key_type);
+    int kh_key_type = (key_type == LIBSSH2_HOSTKEY_TYPE_RSA) ? LIBSSH2_KNOWNHOST_KEY_SSHRSA : LIBSSH2_KNOWNHOST_KEY_SSHDSS;
+    type_str = strdup((key_type == LIBSSH2_HOSTKEY_TYPE_RSA) ? "RSA" : "DSS");
+    
+    int succ = 0;
+    if (key) {
+        struct libssh2_knownhost *knownHost;
+        int check = libssh2_knownhost_checkp(kh, hostname, port, key, key_len,
+                                             LIBSSH2_KNOWNHOST_TYPE_PLAIN | LIBSSH2_KNOWNHOST_KEYENC_RAW | kh_key_type,
+                                             &knownHost);
+        if (check == LIBSSH2_KNOWNHOST_CHECK_FAILURE) {
+            fprintf(stderr, "Known host check failed\n");
+        } else if (check == LIBSSH2_KNOWNHOST_CHECK_NOTFOUND) {
+            fprintf(stderr, "The authenticity of host %.200s (%s) can't be established.\n", hostname, addr);
+        } else if (check == LIBSSH2_KNOWNHOST_CHECK_MISMATCH) {
+            fprintf(stderr, "@@@@@@ REMOTE HOST IDENTIFICATION HAS CHANGED @@@@@@\n%s host key for %.200s (%s) has changed.\nThis might be due to someone doing something nasty or just a change in the host.\n", type_str, hostname, addr);
+        } else if (check == LIBSSH2_KNOWNHOST_CHECK_MATCH) {
+            succ = 1;
+        }
+        free(type_str); 
+    }
+    // Automatically add host to list of authorized hosts
+    if (!succ) {
+        // [self authorize_new_key:key length:key_len type:kh_key_type knownHosts:kh filePath:khFilePath];
+        // Add key to the server
+        int rc = libssh2_knownhost_addc(kh, hostname,
+                                    NULL, // No hashed addr, no salt
+                                    key, key_len,
+                                    NULL, 0,                                                                // No comment
+                                    LIBSSH2_KNOWNHOST_TYPE_PLAIN | LIBSSH2_KNOWNHOST_KEYENC_RAW | LIBSSH2_KNOWNHOST_KEY_SSHRSA, // kh_key_type, 
+                                    NULL);                                                                  // No pointer to the stored structure
+        if (rc < 0) {
+            char *errmsg;
+            libssh2_session_last_error(_session, &errmsg, NULL, 0);
+            fprintf(stderr, "Error adding to the list of known hosts: %s\n", errmsg);
+        }
+        
+        rc = libssh2_knownhost_writefile(kh, khFilePath, LIBSSH2_KNOWNHOST_FILE_OPENSSH);
+        if (rc < 0) {
+            char *errmsg;
+            libssh2_session_last_error(_session, &errmsg, NULL, 0);
+            fprintf(stderr, "Error writing known host: %s\n", errmsg);
+        } else {
+            fprintf(stderr, "Permanently added key for %s to list of known hosts.\n", hostname);
+        }
+    }
+    libssh2_knownhost_free(kh);
+    return succ;
+}
+    
+static int ssh_set_nonblock(int fd) {
+    int arg;
+    if ((arg = fcntl(fd, F_GETFL, NULL)) < 0) {
+        fprintf(stderr, "Error fcntl(..., F_GETFL) (%s)\n", strerror(errno));
+        return -1;
+    }
+    arg |= O_NONBLOCK;
+    if (fcntl(fd, F_SETFL, arg) < 0) {
+        fprintf(stderr, "Error fcntl(..., F_GETFL) (%s)\n", strerror(errno));
+        return -1;
+    }
+    return 0;
+}
+    
+static int ssh_unset_nonblock(int fd) {
+    int arg;
+    
+    if ((arg = fcntl(fd, F_GETFL, NULL)) < 0) {
+        fprintf(stderr, "Error fcntl(..., F_GETFL) (%s)\n", strerror(errno));
+        return -1;
+    }
+    arg &= (~O_NONBLOCK);
+    if (fcntl(fd, F_SETFL, arg) < 0) {
+        fprintf(stderr, "Error fcntl(..., F_GETFL) (%s)\n", strerror(errno));
+        return -1;
+    }
+    return 0;
+}
+    
+static int ssh_client_loop(LIBSSH2_SESSION *_session, LIBSSH2_CHANNEL *_channel, int _sock) {
+    int numfds = 2;
+    struct pollfd pfds[numfds];
+    ssize_t rc;
+    char inputbuf[BUFSIZ];
+    char streambuf[BUFSIZ];
+    
+    ssh_set_nonblock(_sock);
+    ssh_set_nonblock(fileno(child_stdin));
+    
+    libssh2_channel_set_blocking(_channel, 0);
+    
+    memset(pfds, 0, sizeof(struct pollfd) * numfds);
+    
+    pfds[0].fd = _sock;
+    pfds[0].events = 0;
+    pfds[0].revents = 0;
+    
+    pfds[1].fd = fileno(child_stdin);
+    pfds[1].events = POLLIN;
+    pfds[1].revents = 0;
+    
+    // Wait for stream->in or socket while not ready for reading
+    do {
+        if (!pfds[0].events || pfds[0].revents & (POLLIN)) {
+            // Read from socket
+            do {
+                rc = libssh2_channel_read(_channel, inputbuf, BUFSIZ);
+                if (rc > 0) {
+                    fwrite(inputbuf, rc, 1, child_stdout);
+                    fflush(child_stdout);
+                    pfds[0].events = 0;
+                } else if (rc == LIBSSH2_ERROR_EAGAIN) {
+                    // Request the socket for input
+                    pfds[0].events = POLLIN;
+                }
+                memset(inputbuf, 0, BUFSIZ);
+            } while (LIBSSH2_ERROR_EAGAIN != rc && rc > 0);
+            
+            do {
+                rc = libssh2_channel_read_stderr(_channel, inputbuf, BUFSIZ);
+                if (rc > 0) {
+                    fwrite(inputbuf, rc, 1, child_stderr);
+                    pfds[0].events |= 0;
+                } else if (rc == LIBSSH2_ERROR_EAGAIN) {
+                    pfds[0].events = POLLIN;
+                }
+                
+                memset(inputbuf, 0, BUFSIZ);
+                
+            } while (LIBSSH2_ERROR_EAGAIN != rc && rc > 0);
+        }
+        if (rc < 0 && LIBSSH2_ERROR_EAGAIN != rc) {
+            fprintf(stderr, "error reading from socket. exiting...\n");
+            break;
+        }
+        
+        if (libssh2_channel_eof(_channel)) {
+            break;
+        }
+        
+        rc = poll(pfds, numfds, 15000);
+        if (-1 == rc) {
+            break;
+        }
+        
+        ssize_t towrite = 0;
+        
+        if (!child_stdin || feof(child_stdin)) {
+            // Propagate the EOF to the other end
+            libssh2_channel_send_eof(_channel);
+            break;
+        }
+        // Input from stream
+        if (pfds[1].revents & POLLIN) {
+            towrite = fread(streambuf, 1, BUFSIZ, child_stdin);
+            rc = 0;
+            do {
+                rc = libssh2_channel_write(_channel, streambuf + rc, towrite);
+                if (rc > 0) {
+                    towrite -= rc;
+                }
+            } while (LIBSSH2_ERROR_EAGAIN != rc && rc > 0 && towrite > 0);
+            memset(streambuf, 0, BUFSIZ);
+        }
+        if (rc < 0 && LIBSSH2_ERROR_EAGAIN != rc) {
+            char *errmsg;
+            libssh2_session_last_error(_session, &errmsg, NULL, 0);
+            fprintf(stderr, "%s\n", errmsg);
+            fprintf(stderr, "error writing to socket. exiting...\n");
+            break;
+        }
+    } while (1);
+    
+    // We got out of the main loop.
+    // Free resources and try to cleanup
+    ssh_unset_nonblock(_sock);
+    if (child_stdin) {
+        ssh_unset_nonblock(fileno(child_stdin));
+    }
+    
+    while ((rc = libssh2_channel_close(_channel)) == LIBSSH2_ERROR_EAGAIN)
+        ssh_waitsocket(_sock, _session);
+    // close files if it's not a pipe
+    if (fileno(child_stdin) != fileno(stdin)) { fclose(child_stdin);}
+    if (fileno(child_stdout) != fileno(stdout)) { fclose(child_stdout);}
+    if (fileno(child_stderr) != fileno(stderr)) { fclose(child_stderr);}
+    
+    if (rc < 0) {
+        return -1;
+    }
+    return 0;
+}
+    
+static int ssh_timeout_connect(int _sock, const struct sockaddr *addr, socklen_t len, int * timeoutp) {
+    struct timeval tv;
+    fd_set fdset;
+    int res;
+    int valopt = 0;
+    socklen_t lon;
+    
+    if (ssh_set_nonblock(_sock) != 0) {
+        return -1;
+    }
+    
+    // Trying to initiate connection as nonblock
+    res = connect(_sock, addr, len);
+    if (res == 0) {
+        return ssh_unset_nonblock(_sock);
+    }
+    if (errno != EINPROGRESS) {
+        return -1;
+    }
+    
+    do {
+        // Set timeout params
+        tv.tv_sec = *timeoutp;
+        tv.tv_usec = 0;
+        FD_ZERO(&fdset);
+        FD_SET(_sock, &fdset);
+        // Try to select it to write
+        res = select(_sock + 1, NULL, &fdset, NULL, &tv);
+        
+        if (res != -1 || errno != EINTR) {
+            //fprintf(stderr, "Error connecting %d - %s\n", errno, strerror(errno));
+            break;
+        }
+    } while (1);
+    
+    switch (res) {
+        case 0:
+            // Timed out message
+            errno = ETIMEDOUT;
+            return -1;
+        case -1:
+            // Select failed
+            return -1;
+        case 1:
+            // Completed or failed. Socket selected for write
+            valopt = 0;
+            lon = sizeof(valopt);
+            
+            lon = sizeof(int);
+            if (getsockopt(_sock, SOL_SOCKET, SO_ERROR, &valopt, &lon) == -1) {
+                return -1;
+            }
+            if (valopt != 0) {
+                errno = valopt;
+                return -1;
+            }
+            return ssh_unset_nonblock(_sock);
+            
+        default:
+            return -1;
+    }
+}
+    
+    
+int ssh_main(int argc, char** argv) {
+    // TODO: extract options
+    char* passphrase;
+    int port = 22;
+    int connection_timeout = 10;
+    char strport[NI_MAXSERV];
+    snprintf(strport, sizeof strport, "%d", port);
+    // What is the *real* number of arguments?
+    // argv[0] = "ssh hg@bitbucket.org 'hg -R repository'" happens. Other variants too.
+    char* user;
+    char* host;
+    char* commandLine;
+    if (argc == 1) {
+        // Single argument, all in one command line
+        user = argv[0] + 4; // skip past "ssh "
+        host = strchr(user, '@') + 1; // host = after the "@"
+        *(host - 1) = 0x00; // null-terminate user
+        commandLine = strchr(host, ' ') + 1; // commandline = after the ' '
+        *(commandLine -1) = 0x00; // null-terminate host
+        if ((commandLine[0] == '\'') || (commandLine[0] == '\"')) {
+            commandLine += 1; // skip past the opening quote
+            unsigned long l = strlen(commandLine);
+            commandLine[l - 1] = 0x00; // null-terminate and remove closing quote
+        }
+    } else {
+        // Assume several arguments, making sense
+        // argv[0] = ssh
+        // argv[1] = user@host
+        user = argv[1];
+        host = strchr(user, '@') + 1;
+        *(host - 1) = 0x00; // null-terminate host
+        // Concatenate all remaining options to form the command string:
+        int bufferLength = 0;
+        int removeQuotes = 0;
+        for (int i = 2; i < argc; i++) bufferLength += strlen(argv[i]) + 1;
+        if ((argv[2][0] == '\'') || (argv[2][0] == '\"')) { removeQuotes = 1; bufferLength -= 2;} // remove the quotes
+        char* commandLine = (char*) malloc(bufferLength * sizeof(char));
+        int position = 0;
+        strcpy(commandLine + position, argv[optind] + removeQuotes);
+        position += strlen(argv[optind]) + 1 - removeQuotes;
+        commandLine[position - 1] = ' ';
+        for (int i = optind + 1; i < argc; i++) {
+            strcpy(commandLine + position, argv[i]);
+            position += strlen(argv[i]) + 1;
+            commandLine[position - 1] = ' ';
+        }
+        commandLine[bufferLength - 1] = 0x0; // null-terminate the command
+    }
+    // Does the hostname exist?
+    struct addrinfo hints, *addrs;
+    struct sockaddr_storage hostaddr;
+    // TODO: Use Python error reporting system.
+    // ssh_connect
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = PF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+    int res;
+    if ((res = getaddrinfo(host, strport, &hints, &addrs)) != 0) { fprintf(stderr, "Host %s not found on port %s, error= %s.\n", host, strport, gai_strerror(res));  return 0;}
+    struct addrinfo *ai;
+    char ntop[NI_MAXHOST];
+    int _sock = -1;
+    for (ai = addrs; ai; ai = ai->ai_next) {
+        if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6) {continue;}
+        if (getnameinfo(ai->ai_addr, ai->ai_addrlen,
+                        ntop, sizeof(ntop), strport,
+                        sizeof(strport), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
+            fprintf(stderr, "ssh_connect: getnameinfo failed\n");
+            continue;
+        }
+        _sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+        if (_sock < 0) {
+            fprintf(stderr, "ssh: %s", strerror(errno));
+            if (!ai->ai_next) {
+                fprintf(stderr, "ssh: connect to host %s port %s: %s", host, strport, strerror(errno));
+                return 0;
+            }
+            continue;
+        }
+        // TODO: check timeout_connect
+        if (ssh_timeout_connect(_sock, ai->ai_addr, ai->ai_addrlen, &connection_timeout) >= 0) {
+            // Successful connection. Save host address
+            memcpy(&hostaddr, ai->ai_addr, ai->ai_addrlen);
+            break;
+        } else {
+            fprintf(stderr, "connect to host %s port %s: %s\n", ntop, strport, strerror(errno));
+            _sock = -1;
+        }
+    }
+    // ssh_set_session
+    LIBSSH2_SESSION *_session = libssh2_session_init();
+    if (!_session) {fprintf(stderr, "Could not establish connection with %s.\n", host);  return 0;}
+    libssh2_session_set_blocking(_session, 0);
+    libssh2_session_set_timeout(_session, connection_timeout);
+    LIBSSH2_CHANNEL *_channel;
+    char *errmsg;
+    int rc;
+    while ((rc = libssh2_session_handshake(_session, _sock)) ==
+           LIBSSH2_ERROR_EAGAIN);
+    if (rc) {
+        libssh2_session_last_error(_session, &errmsg, NULL, 0);
+        fprintf(stderr, "SSH error: %s\n", errmsg);
+        return -1;
+    }
+    // Set object as handler
+    // void **handler = libssh2_session_abstract(_session);
+    // Verify host key
+    if (ssh_verify_host(ntop, _session, host, port) <= 0) {fprintf(stderr, "Could not check host key %s.\n", host);  return 0;}
+    // Connect: ssh_login
+    char *userauthlist = NULL;
+    int auth_type;
+    do {
+        userauthlist = libssh2_userauth_list(_session, user, (int)strlen(user));
+        if (!userauthlist) {
+            if (libssh2_session_last_errno(_session) != LIBSSH2_ERROR_EAGAIN) {
+                fprintf(stderr, "No userauth list\n");
+                return 0;
+            } else {
+                ssh_waitsocket(_sock, _session); /* now we wait */
+            }
+        }
+    } while (!userauthlist);
+    if (strstr(userauthlist, "password") != NULL) {
+        auth_type |= 1;
+    }
+    if (strstr(userauthlist, "keyboard-interactive") != NULL) {
+        auth_type |= 2;
+    }
+    if (strstr(userauthlist, "publickey") != NULL) {
+        auth_type |= 4;
+    }
+    if (auth_type & 4) {
+        // Most common case.
+        // Path = getenv(SSH_HOME) or ~/Documents
+        char path[PATH_MAX];
+        if (getenv("SSH_HOME")) strcpy(path, getenv("SSH_HOME"));
+        else sprintf(path, "%s/Documents", getenv("HOME"));
+        char keypath[PATH_MAX];
+        sprintf(keypath, "%s/.ssh/", path);
+        // Loop over all keys in .ssh directory
+        DIR* dirp = opendir(keypath);
+        if (!dirp) dirp = opendir(path);
+        if (!dirp) {fprintf(stderr, "Can't open directory %s\n", keypath); return 0;}
+        struct dirent *dp;
+        char* suffix = ".pub";
+        long suffix_len = strlen(suffix);
+        while ((dp = readdir(dirp)) != NULL) {
+            // does this file end in ".pub"?
+            char* publickeyName = dp->d_name;
+            if (strncmp( publickeyName + strlen(publickeyName) - suffix_len, suffix, suffix_len ) != 0) continue;
+            // is there a file with same name, without .pub?
+            char* privatekeyName = strdup(publickeyName);
+            privatekeyName[strlen(publickeyName) - suffix_len] = 0x0;
+            char publickeypath[PATH_MAX];
+            char privatekeypath[PATH_MAX];
+            sprintf(publickeypath, "%s%s", keypath, publickeyName);
+            sprintf(privatekeypath, "%s%s", keypath, privatekeyName);
+            if (access( privatekeypath, F_OK ) == -1) continue;
+            while ((rc = libssh2_userauth_publickey_fromfile_ex(_session,
+                                                   user,
+                                                   strlen(user),
+                                                   publickeypath,
+                                                   privatekeypath, passphrase))  == LIBSSH2_ERROR_EAGAIN);
+            if (rc != 0) { fprintf(stderr, "Authentification failure with passphrase.\n"); continue; } // try another key
+            // We are connected
+            rc = 0;
+            char *errmsg;
+            while ((_channel = libssh2_channel_open_session(_session)) == NULL &&
+                   libssh2_session_last_error(_session, NULL, NULL, 0) == LIBSSH2_ERROR_EAGAIN) {
+                ssh_waitsocket(_sock, _session);
+            }
+            if (_channel == NULL) {
+                libssh2_session_last_error(_session, &errmsg, NULL, 0);
+                fprintf(stderr, "ssh: error creating channel: %s\n", errmsg);
+                rc = -1;
+                break;
+            }
+            while ((rc = libssh2_channel_exec(_channel, commandLine)) == LIBSSH2_ERROR_EAGAIN) {
+                    ssh_waitsocket(_sock, _session);
+            }
+            if (rc != 0) {
+                libssh2_session_last_error(_session, &errmsg, NULL, 0);
+                fprintf(stderr, "ssh: error exec: %s\n", errmsg);
+                rc = -1;
+                break;
+            }
+            rc = ssh_client_loop(_session, _channel, _sock); // data transmission
+            break;
+        }
+        // cleanup:
+        (void)closedir(dirp);
+        if (rc >= 0) {
+            libssh2_channel_free(_channel);
+            libssh2_session_free(_session);
+            _channel = NULL;
+            return rc;
+        }
+        fprintf(stderr, "Authentification with public key failed\n");
+    }
+    // public key auth failed
+    fprintf(stderr, "Password authentification not supported\n");
+    // libssh2_channel_free(_channel);
+    libssh2_session_free(_session);
+    _channel = NULL;
+    
+    return -1;
+}
+    
+#ifdef BLINKSHELL
+#include <Foundation/Foundation.h>
+#include <UIKit/UIKit.h>
+#endif
+extern int ios_system(char* cmd);
+
+void* exec_thread(void* param) {
+    char** argv = (char**) param;
+    // path and argv[0] are the same (not in theory, but in practice since Python wrote the command)
+    // If this is a ssh command, it's probably a socket (for mercurial), so we keep it local.
+    int argc = 0;
+    if ((strncmp(argv[0], "ssh", 3) == 0) && ((strlen(argv[0]) == 3) || (argv[0][3] == ' '))) {
+        while (argv[argc] != NULL) argc++;
+        ssh_main(argc, argv);
+        return NULL;
+    }
+#ifndef BLINKSHELL
+    int cmdLength = 0;
+    while(argv[argc] != NULL) { cmdLength += strlen(argv[argc]) + 1; argc++;}
+    char* cmd = malloc(cmdLength * sizeof(char));
+    argc = 0;
+    strcpy(cmd, argv[0]);
+    while (argv[argc] != NULL) {
+        strcat(cmd, " ");
+        strcat(cmd, argv[argc]);
+        argc++;
+    }
+    ios_system(cmd);
+    free(cmd);
+#else
+    // Otherwise, we send it to blinkshell:
+    // a) concatenate everything into a single string. BlinkShell will do the parsing.
+    NSString* command = @"blinkshell://";
+    argc = 0;
+    while (argv[argc] != NULL) {
+        // arguments in python can have spaces inside them
+        // use %1E to separate arguments:
+        if (argc != 0) command = [command stringByAppendingString:[NSString stringWithFormat:@"%%1E"]];
+        // convert spaces to percents, add argument to URL string:
+        command = [command stringByAppendingString:[[NSString stringWithFormat:@"%s", argv[argc]] stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]]];
+        argc++;
+    }
+    NSURL *commandURL = [NSURL URLWithString:command];
+    dispatch_async(dispatch_get_main_queue(), ^{ // iOS 11, sending openURL to main application
+        [[UIApplication sharedApplication] openURL:commandURL options:@{} completionHandler:nil];
+    });
+#endif
+    return NULL;
+}
+    
+int execv(const char *path, char* const argv[]) {
+    pthread_t _tid;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    pthread_create(&_tid, &attr, exec_thread, argv);
+    return 0;
+}
+    
+int execve(const char *path, char* const argv[], char *const envp[]) {
+    // TODO: save the environment (HOW?) and current dir
+    // TODO: replace environment with envp. envp looks a lot like environment, though.
+    pthread_t _tid;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    pthread_create(&_tid, &attr, exec_thread, argv);
+    // TODO: restore the environment (HOW?)
+    return 0;
+}
+    
+#endif // TARGET_OS_IPHONE
+    
+    
 
 #ifndef MS_WINDOWS
 PyObject *
@@ -629,7 +1230,6 @@
 ** man environ(7).
 */
 #include <crt_externs.h>
-static char **environ;
 #elif !defined(_MSC_VER) && ( !defined(__WATCOMC__) || defined(__QNX__) )
 extern char **environ;
 #endif /* !_MSC_VER */
@@ -2175,7 +2775,7 @@
     Py_BEGIN_ALLOW_THREADS
     do {
         bufsize = bufsize + bufsize_incr;
-        tmpbuf = malloc(bufsize);
+        tmpbuf = (char*) malloc(bufsize);
         if (tmpbuf == NULL) {
             break;
         }
@@ -2841,7 +3441,22 @@
     if (!PyArg_ParseTuple(args, "s:system", &command))
         return NULL;
     Py_BEGIN_ALLOW_THREADS
+#ifdef TARGET_OS_IPHONE
+#ifndef BLINKSHELL
+    ios_system(command);
+#else
+    // Otherwise, we send it to blinkshell:
+    NSString* myCommand = @"blinkshell://";
+    myCommand = [myCommand stringByAppendingString:[NSString stringWithFormat:@"%s", command]];
+    NSURL *commandURL = [NSURL URLWithString:[myCommand stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]]];
+    dispatch_async(dispatch_get_main_queue(), ^{ // iOS 11, sending openURL to main application
+        [[UIApplication sharedApplication] openURL:commandURL options:@{} completionHandler:nil];
+    });
+    sts = true;
+#endif
+#else
     sts = system(command);
+#endif
     Py_END_ALLOW_THREADS
     return PyInt_FromLong(sts);
 }
@@ -3123,7 +3738,8 @@
     int sts;
     if (!PyArg_ParseTuple(args, "i:_exit", &sts))
         return NULL;
-    _exit(sts);
+    pthread_exit(NULL);
+    // _exit(sts);
     return NULL; /* Make gcc -Wall happy */
 }
 
@@ -3155,7 +3771,7 @@
     char **argvlist;
     Py_ssize_t i, argc;
     PyObject *(*getitem)(PyObject *, Py_ssize_t);
-
+    
     /* execv has two arguments: (path, argv), where
        argv is a list or tuple of strings. */
 
@@ -3196,15 +3812,16 @@
                             "execv() arg 2 must contain only strings");
             PyMem_Free(path);
             return NULL;
-
         }
     }
     argvlist[argc] = NULL;
-
     execv(path, argvlist);
-
+#ifdef TARGET_OS_IPHONE
+      Py_INCREF(Py_None);
+      return Py_None;
+#endif
+    
     /* If we get here it's definitely an error */
-
     free_string_array(argvlist, argc);
     PyMem_Free(path);
     return posix_error();
@@ -3218,7 +3835,7 @@
     path: path of executable file\n\
     args: tuple or list of arguments\n\
     env: dictionary of strings mapping to strings");
-
+    
 static PyObject *
 posix_execve(PyObject *self, PyObject *args)
 {
@@ -3230,7 +3847,7 @@
     Py_ssize_t i, pos, argc, envc;
     PyObject *(*getitem)(PyObject *, Py_ssize_t);
     Py_ssize_t lastarg = 0;
-
+    
     /* execve has three arguments: (path, argv, env), where
        argv is a list or tuple of strings and env is a dictionary
        like posix.environ. */
@@ -3333,8 +3950,12 @@
 #endif
     }
     envlist[envc] = 0;
-
+    
     execve(path, argvlist, envlist);
+#ifdef TARGET_OS_IPHONE
+        Py_INCREF(Py_None);
+        return Py_None;
+#endif
 
     /* If we get here it's definitely an error */
 
@@ -3866,9 +4487,14 @@
 static PyObject *
 posix_fork(PyObject *self, PyObject *noargs)
 {
+#ifdef TARGET_OS_IPHONE
+    PyObject* newPid = PyLong_FromPid(0);
+    return newPid;
+#endif
     pid_t pid;
     int result = 0;
     _PyImport_AcquireLock();
+    
     pid = fork();
     if (pid == 0) {
         /* child: this clobbers and resets the import lock. */
@@ -4107,7 +4733,7 @@
         /* groups will fit in existing array */
         alt_grouplist = grouplist;
     } else {
-        alt_grouplist = PyMem_Malloc(n * sizeof(gid_t));
+        alt_grouplist = (gid_t*) PyMem_Malloc(n * sizeof(gid_t));
         if (alt_grouplist == NULL) {
             errno = EINVAL;
             return posix_error();
@@ -6690,9 +7316,19 @@
         return NULL;
     if (!_PyVerify_fd_dup2(fd, fd2))
         return posix_error();
+#ifdef TARGET_OS_IPHONE
+    res = 1;
+    if (fd2 == 0) { child_stdin = fdopen(fd, "rb"); }
+    else if (fd2 == 1) { child_stdout = fdopen(fd, "wb"); }
+    else if (fd2 == 2) { child_stderr = fdopen(fd, "wb"); }
+    else res = dup2(fd, fd2);
+    // TODO: rewrite "*_main" to include child_stdin/child_stdout to be more thread friendly
+    // TODO: test again with p2cread open in the right direction ("r") -- sinon a va marcher moins bien
+#else
     Py_BEGIN_ALLOW_THREADS
     res = dup2(fd, fd2);
     Py_END_ALLOW_THREADS
+#endif
     if (res < 0)
         return posix_error();
     Py_INCREF(Py_None);
@@ -6874,7 +7510,7 @@
         return NULL;
 
     /* Sanitize mode.  See fileobject.c */
-    mode = PyMem_MALLOC(strlen(orgmode)+3);
+    mode = (char*) PyMem_MALLOC(strlen(orgmode)+3);
     if (!mode) {
         PyErr_NoMemory();
         return NULL;
diff -Naur Python-2.7.13/Modules/python.c ../Python-2.7.13/Modules/python.c
--- Python-2.7.13/Modules/python.c	2016-12-17 21:05:07.000000000 +0100
+++ ../Python-2.7.13/Modules/python.c	2017-07-04 15:34:28.000000000 +0200
@@ -7,7 +7,7 @@
 #endif
 
 int
-main(int argc, char **argv)
+python_main(int argc, char **argv)
 {
 	/* 754 requires that FP exceptions run in "no stop" mode by default,
 	 * and until C vendors implement C99's ways to control FP exceptions,
